package game.world;

import java.awt.Color;
import java.awt.Graphics2D;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;

import javax.imageio.ImageIO;
import javax.sound.sampled.Line;

import game.Game;
import game.entity.Entity;
import game.entity.EntityBoop;
import game.entity.EntityGoal;
import game.entity.EntityMovingTile;
import game.entity.Mob;
import game.entity.PlatformType;
import game.entity.Player;
import game.render.ParallaxEngine;
import game.render.ParallaxLayer;
import game.render.textures.Texture;
import game.utils.math.Triangle;

public class TileMap {

	private String name;
	private int width, height;
	private Tile[] tiles; // MAKE THIS A DOUBLE ARRAY BOI

	private static final int TILE_SIZE = 64;
	private static final int TILE_SIZE_BITS = 6;
	private double newX;

	private Player player;
	private ParallaxEngine parallaxEngine;
	private ArrayList<Entity> entities;

	private ArrayList<Triangle> slopeTriangles = new ArrayList<Triangle>();
	
	public ArrayList<Tile> usedTiles = new ArrayList<Tile>();

	private boolean isOnMovingTile;

	private Triangle test1 = new Triangle(new Point(128, Game.HEIGHT/** Game.SCALEFACTOR */
			- 64), 64, Math.PI / 4);

	boolean first;

	double newPosY;

	public TileMap(String name) {
		entities = new ArrayList<Entity>();
		ParallaxLayer layer1 = new ParallaxLayer(new Texture("background13"), (int) ((16 * 0.25) * -0.23));
		ParallaxLayer layer2 = new ParallaxLayer(new Texture("background2"), (int) ((16 * 0.25) * -0.3));
		ParallaxLayer layer3 = new ParallaxLayer(new Texture("background32"), (int) ((16 * 0.25) * -0.6));
		this.parallaxEngine = new ParallaxEngine(layer1, layer2, layer3);
		load(name);
	}

	public Tile getTile(int x, int y) {
		if (x < 0 || x >= width || y < 0 || y >= height) {
			return null;
		} else {
			return tiles[x + y * width];
		}
	}

	public void setTile(int x, int y, Tile tile) {
		tiles[x + y * width] = tile; // proper math?
		usedTiles.add(new Tile(tile,x*64,y*64));
	}

	public static int convertToTiles(int pixel) {
		// return (int)Math.round(pixel / 64); // this can be done with *return pixel >>
		// TILE_SIZE_BITS;* but it will truncate as opposed to round, so this is better
		return pixel >> TILE_SIZE_BITS;
	}

	public static int convertToPixels(int tile) {
		return tile << TILE_SIZE_BITS;
	}

	public static int getTilePos(int posIn) {
		return (posIn >> TILE_SIZE_BITS) << TILE_SIZE_BITS;
	}

	public void tick() {
		player.tick();
		if (player.isMovingLeft()) {
			parallaxEngine.setLeft();
		} else {
			if (player.isMovingRight()) {
				parallaxEngine.setRight();
			}
		}
		if (player.isMoving()) {
			parallaxEngine.setMove(player.getMotionX());
		}
		for (int i = 0; i < entities.size(); i++) {
			entities.get(i).tick();
		}
		// player.tick();
	}

	public void render(Graphics2D g2d, int screenWidth, int screenHeight) {

		int mapWidth = convertToPixels(width);
		int mapHeight = convertToPixels(height);
		int offsetX = (int) (screenWidth / 2 - player.getX() - TILE_SIZE / 2);
		int offsetY = (int) (screenHeight / 2 - player.getY() - TILE_SIZE / 2);
		offsetX = Math.min(offsetX, 0);
		offsetX = Math.max(offsetX, screenWidth - mapWidth);
		offsetY = Math.min(offsetY, 0);
		offsetY = Math.max(offsetY, screenHeight - mapHeight);

		int firstX = convertToTiles(-offsetX);
		int lastX = firstX + convertToTiles(screenWidth) + 1;
		int firstY = convertToTiles(-offsetY);
		int lastY = firstY + convertToTiles(screenHeight) + 1;

		parallaxEngine.render(g2d);

		for (int y = firstY; y <= lastY; y++) {
			for (int x = firstX; x <= lastX; x++) {
				Tile t = getTile(x, y);
				if (t != null) {
					//t.render(g2d, convertToPixels(x) + offsetX, convertToPixels(y) + offsetY);
				}
				if (Game.showTileMap) {
					g2d.setColor(Color.RED);
					g2d.drawRect(convertToPixels(x) + offsetX, convertToPixels(y) + offsetY, 64, 64);
				}
			}
		}
		
		for(Tile t : usedTiles) {
			t.render(g2d, t.x + offsetX, t.y + offsetY);
		}

		for (int i = 0; i < entities.size(); i++) {
			entities.get(i).render(g2d, offsetX, offsetY);
		}
		player.render(g2d, offsetX, offsetY);
		if (Game.debug) {
			g2d.setColor(Color.GREEN);
			if (player.getAABB() != null) {
				g2d.drawRect((int) player.getAABB().getX() + offsetX, (int) player.getAABB().getY() + offsetY,
						(int) player.getAABB().getWidth(), (int) player.getAABB().getHeight());
				g2d.drawLine((int) (player.getX() + 32 + 14 + offsetX), (int) (player.getY() + 32 + offsetY),
						(int) (player.getX() + 32 + 14 + offsetX), (int) (player.getY() + 32 + 26 + 16 + offsetY));
				g2d.drawLine((int) (player.getX() + 32 - 14 + offsetX), (int) (player.getY() + 32 + offsetY),
						(int) (player.getX() + 32 - 14 + offsetX), (int) (player.getY() + 32 + 26 + 16 + offsetY));
				g2d.drawLine((int)player.getX() + 32 - 24 + offsetX, (int)player.getY() + 32 + 6 + offsetY, (int)player.getX() + 32 + 24 + offsetX, (int)player.getY() + 32 + 6 + offsetY);
				
				g2d.drawLine((int)player.getX() + 32 - 24 + offsetX, (int)player.getY() + 60 + offsetY, (int)player.getX() + 32 + 24 + offsetX, (int)player.getY() + 60 + offsetY);
			}
			g2d.setColor(Color.BLUE);
			g2d.drawRect((int) player.getX() + offsetX, (int) player.getY() + offsetY, 64, 64);

		}
		g2d.setColor(Color.WHITE);
		for (Triangle t : slopeTriangles) {
			t.render(g2d, offsetX, offsetY);
		}
		test1.render(g2d, offsetX, offsetY);

	}

	public double groundFloor(double centerX, double centerY, int j, double newY, double horzModifier) {
		for (int i = j; i >= 0; i--) {
			{
				if (true/*
						 * getTile(convertToTiles((int) horzModifier), convertToTiles((int) centerY +
						 * i)).type.isNotAir()
						 */) {
					Tile t3 = getTile(convertToTiles((int) horzModifier), convertToTiles((int) centerY + i));

					/*
					 * if ((int)player.getY() + 64 - t3.heightMask[(int) (horzModifier) -
					 * getTilePos((int) (horzModifier))] <= player.getY()) { newY =
					 * t3.heightMask[(int) (horzModifier) - getTilePos((int) (horzModifier))]; }
					 */

					newY = t3.heightMask[(int) (horzModifier) - getTilePos((int) (horzModifier))];

					/*
					 * boolean b = true; if(TileType.isCubeType(t3.type)) { if(intersectsSlope()) {
					 * b = false; } }
					 * 
					 * if(b) { newY = t3.heightMask[(int) (horzModifier) - getTilePos((int)
					 * (horzModifier))]; }
					 */

					if (player.getY() == 832) {
						// System.out.println("wat");
					}

					if (true/* TileType.isCubeType(t3.type) */) {
						if (getTile(convertToTiles((int) horzModifier), convertToTiles((int) centerY + i) - 1).type
								.isNotAir() && !player.falling) {
							Tile t1 = getTile(convertToTiles((int) horzModifier),
									convertToTiles((int) centerY + i) - 1);
							if (t1.heightMask[(int) (horzModifier) - getTilePos((int) (horzModifier))] != 0) {
								// System.out.println(t1.heightMask[(int) (horzModifier) - getTilePos((int)
								// (horzModifier))]);
								if (player.getY() < convertToPixels(convertToTiles((int) centerY + i) - 1)
										- t1.heightMask[(int) (horzModifier) - getTilePos((int) (horzModifier))]) {
									player.setY(convertToPixels(convertToTiles((int) centerY + i) - 1)
											- t1.heightMask[(int) (horzModifier) - getTilePos((int) (horzModifier))]);
								} else {
									player.setY(convertToPixels(convertToTiles((int) centerY + i) - 1)
											- t1.heightMask[(int) (horzModifier) - getTilePos((int) (horzModifier))]);
								}
								// System.out.println(player.getY() - t1.heightMask[(int) (horzModifier) -
								// getTilePos((int) (horzModifier))]);
								// player.falling = false;
								player.setMotionY(0);
								return Double.MAX_VALUE;
							} else {
								if (getTile(convertToTiles((int) horzModifier), convertToTiles((int) centerY + i)).type
										.isNotAir()) {
									player.setY(getTilePos((int) player.getY()) + 64 - newY);
									player.falling = false;
									player.setMotionY(0);
								}
							}
						} else {
							if (getTile(convertToTiles((int) horzModifier), convertToTiles((int) centerY + i)).type
									.isNotAir()) {
								if (newY != Double.MIN_VALUE) {
									if (player.getY() < getTilePos((int) player.getY()) + 64 - newY || player.falling) {

										player.setY(getTilePos((int) player.getY()) + 64 - newY);
									} else {
										player.setY(getTilePos((int) player.getY() + i - 26 - 10) + 64 - newY);
									}
									// System.out.println(getTilePos((int) player.getY() + 1) + 64 - newY);
									player.falling = false;
									player.setMotionY(0);
									return Double.MAX_VALUE;
								}
								// System.out.println(getTilePos((int) player.getY()) + 64 - newY);
								// player.setY(getTilePos((int)player.getY()));

							}

						}

					} else {
						player.setY(getTilePos((int) player.getY()) + 64 - newY);
						player.falling = false;
						player.setMotionY(0);
						// return newY;
					}
				}
			}
		}
		return newY;
	}

	public boolean intersectsSlope() {
		return TileType.isSlope(getTile(convertToTiles((int) player.getX()), convertToTiles((int) player.getY())).type)
				|| TileType.isSlope(
						getTile(convertToTiles((int) player.getX()), convertToTiles((int) player.getY() + 64)).type)
				|| TileType.isSlope(
						getTile(convertToTiles((int) player.getX() + 64), convertToTiles((int) player.getY())).type)
				|| TileType.isSlope(getTile(convertToTiles((int) player.getX() + 64),
						convertToTiles((int) player.getY() + 64)).type);
	}

	public void fallingOff(double centerX, double centerY) {
		for (int i = (26 + 16); i >= 0; i--) {
			if (getTile(convertToTiles((int) centerX + 14), convertToTiles((int) centerY + i)).type.isNotAir()
					|| getTile(convertToTiles((int) centerX - 14), convertToTiles((int) centerY + i)).type.isNotAir()) {
				return;
			}
			
		}

		player.falling = true;
	}

	public boolean wallCollision(double motionX, double motionY, double centerX, double xOffset, double xOffsetLow,
			double centerY) {
		if (getTile(convertToTiles((int) (xOffset + motionX)), convertToTiles((int) centerY + 6)) == null) {
			player.setX(centerX - 33);
			player.setMotionX(0);
			player.setMoving(false);
			return true;
		}

		if (getTile(convertToTiles((int) xOffset), convertToTiles((int) centerY + 6)).type.isNotAir() && TileType
				.isCubeType(getTile(convertToTiles((int) xOffset), convertToTiles((int) centerY + 6)).type)) {
			if (player.falling) {
				if (motionX > 0) {
					player.setX(centerX - 33);
					player.setMotionX(0);
					player.setMoving(false);
					// System.out.println(true);
					return true;
				}
			} else {
				player.setX(centerX - 33);
				player.setMotionX(0);
				player.setMoving(false);
				// System.out.println(true);
				return true;
			}
		}

		if (getTile(convertToTiles((int) xOffsetLow), convertToTiles((int) centerY + 6)).type.isNotAir() && TileType
				.isCubeType(getTile(convertToTiles((int) xOffsetLow), convertToTiles((int) centerY + 6)).type)) {
			if (player.falling) {
				if (motionX < 0) {
					player.setX(centerX - 31);
					player.setMotionX(0);
					player.setMoving(false);
					// System.out.println(true);
					return true;
				}
			} else {
				player.setX(centerX - 31);
				player.setMotionX(0);
				player.setMoving(false);
				// System.out.println(true);
				return true;
			}
		}

		return false;
	}

	public boolean enemyCollision(double centerX, double centerY, EntityBoop b) {
		if (b.getAABB().intersectsLine(centerX - 24, centerY + 32, centerX + 24, centerY + 32)) {
			if (centerY < b.getY()) {
				b.onKillHit(player);
			} else {
				b.onHit(player);
			}

			return true;
		}
		return false;
		
		

		

	}
	
	
	public boolean enemyCollision(EntityBoop b) {
		if (player.getAABB().intersects(b.getAABB())) {
			if (b.getY() - player.getY() < 48) {
				b.onHit(player);
			} else {
				b.onKillHit(player);
			}
			
			return true;
		}
		
		return false;
	}
	

	public void sonicCollision(double posX, double posY, double motionX, double motionY) {
		double centerX = posX + 32;
		double centerY = posY + 32;

		if (posX + motionX + 64 >= this.width * 64 || posX + motionX <= 0) {
			player.setMotionX(0);
		}

		if (posY + motionY >= (this.height - 1) * 64) {
			player.setDead();
			return;
		}

		if (posY + motionY <= 0) {
			player.setMotionY(0);
		}

		fallingOff(centerX, centerY);

		// wall collision

		for (int i = 24; i >= 0; i--) {
			if (wallCollision(motionX, motionY, centerX, centerX + i, centerX - i, centerY)) {
				break;
			}
		}

		// floor collision (including slopes)

		if (!(motionY < 0)) {
			double newY = Double.MIN_VALUE;
			// double newPosY = Double.MIN_VALUE;
			if (player.falling) {
				newY = groundFloor(centerX, centerY, 26, newY, centerX + 14);
				if (newY != Double.MAX_VALUE) {
					newY = groundFloor(centerX, centerY, 26, newY, centerX - 14);
				}
			} else {
				newY = groundFloor(centerX, centerY, 26 + 32, newY, centerX + 14);
				if (newY != Double.MAX_VALUE) {
					newY = groundFloor(centerX, centerY, 26 + 32, newY, centerX - 14);
				}
			}
		} else {
			for (int i = 1; i <= 64 - 1; i++) {
				if (ceilingCollision(player.getX() + 32, player.getY())) {
					break;
				}
			}
		}

		// System.out.println(player.getY());

		for (Entity e : entities) {
			if (e instanceof EntityBoop) {
				enemyCollision((EntityBoop) e);
			}
			if(e instanceof EntityMovingTile) {
				
			}
		}

	}
	
	
	
	public void mobFallingOff(double centerX, double centerY, Mob m) {
		for(Tile t : usedTiles) {
			if(!t.isSolid()) {
				continue;
			}
			if((t.AABB.intersectsLine(m.floorCheck1) || t.AABB.intersectsLine(m.floorCheck2))) {
				return;
			}
		}
		
		m.falling = true;
	}

	public boolean mobWallCollision(Mob m) {
		
		for(Tile t : usedTiles) {
			if(!t.isSolid()) {
				continue;
			}
			
			
			if(t.AABB.intersectsLine(m.centerLine)) {
				if (m.getX() < t.x) {
					if (m.falling) {
						if (m.getMotionX() > 0) {
							m.setX(m.center.getX() - 33);
							m.setMotionX(0);
							m.setMoving(false);
							return true;
						}
					} else {
						m.setX(m.center.getX() - 33);
						m.setMotionX(0);
						m.setMoving(false);
						return true;
					} 
				} else {
					if (m.falling) {
						if (m.getMotionX() < 0) {
							m.setX(m.center.getX() - 31);
							m.setMotionX(0);
							m.setMoving(false);
							return true;
						}
					} else {
						m.setX(m.center.getX() - 31);
						m.setMotionX(0);
						m.setMoving(false);
						return true;
					} 
				}
			}
		}
		
		return false;
	}
	
	
	
	
	
	public void mobGroundFloor(double centerX, double centerY, int j, double newY, double horzModifier, Mob m) {
		
		for(Tile t : usedTiles) {
			if(!t.isSolid()) {
				continue;
			}
			
			
			if(m.floorCheck1.contains(m.floorCheck1.getX2(), t.y + 64 - t.heightMask[(int)m.floorCheck1.getX2() - t.x]) || m.floorCheck1.contains(m.floorCheck2.getX2(), t.y + 64 - t.heightMask[(int)m.floorCheck2.getX2() - t.x])) {
				double checkY = t.y + 64 - t.heightMask[(int)m.getX() - t.x];
				double checkY2 = t.y + 64 - t.heightMask[(int)m.floorCheck2.getX2() - t.x];
				double newY = Math.max(checkY, checkY2);
				if(m.falling) {
					if(m.y > checkY) {
						m.setY(y);
					}
				}
			}
	}
	
	
	
	
	
	
	public void EntityCollision(double posX, double posY, double motionX, double motionY, Mob m) {
		double centerX = posX + 32;
		double centerY = posY + 32;

		if (posX + motionX + 64 >= this.width * 64 || posX + motionX <= 0) {
			m.setMotionX(0);
		}

		if (posY + motionY >= (this.height - 1) * 64) {
			m.setDead();
			return;
		}

		if (posY + motionY <= 0) {
			m.setMotionY(0);
		}

		mobFallingOff(centerX, centerY, m);

		// wall collision
		
		mobWallCollision(m);

		// floor collision (including slopes)

		if (!(motionY < 0)) {
			double newY = Double.MIN_VALUE;
			// double newPosY = Double.MIN_VALUE;
			if (m.falling) {
				newY = groundFloor(centerX, centerY, 26, newY, centerX + 14);
				if (newY != Double.MAX_VALUE) {
					newY = groundFloor(centerX, centerY, 26, newY, centerX - 14);
				}
			} else {
				newY = groundFloor(centerX, centerY, 26 + 32, newY, centerX + 14);
				if (newY != Double.MAX_VALUE) {
					newY = groundFloor(centerX, centerY, 26 + 32, newY, centerX - 14);
				}
			}
		} else {
			for (int i = 1; i <= 64 - 1; i++) {
				if (ceilingCollision(player.getX() + 32, player.getY())) {
					break;
				}
			}
		}

		// System.out.println(player.getY());

		for (Entity e : entities) {
			if (e instanceof EntityBoop) {
				enemyCollision((EntityBoop) e);
			}
			if(e instanceof EntityMovingTile) {
				
			}
		}

	}

	
	
	

	/*
	 * public void calculateCollision(Rectangle AABB, double posX, double posY,
	 * double motionX, double motionY) { double toX = posX + motionX; double toY =
	 * posY + motionY; double newX = -1.0;
	 * AABB.setBounds((int)player.adjustXforCollision(toX),
	 * (int)player.adjustYforCollision(posY), AABB.width, AABB.height);
	 * 
	 * 
	 * 
	 * if(getTile(convertToTiles((int)AABB.getMaxX()),
	 * convertToTiles((int)AABB.getMinY() + 1)) != null) { //this is the top right
	 * corner Tile tile = getTile(convertToTiles((int)AABB.getMaxX()),
	 * convertToTiles((int)AABB.getMinY() + 1)); if (tile.type == TileType.SOLID) {
	 * newX = convertToPixels(convertToTiles((int)AABB.getMaxX())) - AABB.getWidth()
	 * - 1 - 5; player.setX(newX);
	 * AABB.setBounds((int)player.adjustXforCollision(newX),
	 * (int)player.adjustYforCollision(posY), AABB.width, AABB.height);
	 * player.setMotionX(0); player.setMoving(false);
	 * 
	 * if(Game.debug) { System.out.println("Collided top right horizontally"); } }
	 * else { if(tile.type == TileType.SLOPE_RIGHT_64_00) { newX = toX;
	 * if(Game.debug) { System.out.println("Walking up a slope"); } } } }
	 * 
	 * if(getTile(convertToTiles((int)AABB.getMaxX()),
	 * convertToTiles((int)AABB.getMaxY() - 1)) != null) { //this is the bottom
	 * right corner Tile tile = getTile(convertToTiles((int)AABB.getMaxX()),
	 * convertToTiles((int)AABB.getMaxY() - 1)); if (tile.type == TileType.SOLID) {
	 * newX = convertToPixels(convertToTiles((int) AABB.getMaxX())) -
	 * AABB.getWidth() - 1 - 5; player.setX(newX); AABB.setBounds((int)
	 * player.adjustXforCollision(newX), (int) player.adjustYforCollision(posY),
	 * AABB.width, AABB.height); player.setMotionX(0); player.setMoving(false);
	 * if(Game.debug) { System.out.println("Collided bottom right horizontally"); }
	 * } else { if(tile.type == TileType.SLOPE_RIGHT_64_00) { newX = toX; //double
	 * bottomSlope = tilesToPixels(pixelsToTiles((int) AABB.getMaxX()));
	 * 
	 * player.setY(convertToPixels(convertToTiles((int)(int)player.
	 * adjustYforCollision(posY) - 1)) + (64 - toX % 64)); if(Game.debug) {
	 * System.out.println("Walking up a slope"); } } } }
	 * 
	 * if(getTile(convertToTiles((int)AABB.getMinX()),
	 * convertToTiles((int)AABB.getMinY() + 1)) != null) { //this is the top left
	 * corner newX = convertToPixels(convertToTiles((int)AABB.getMaxX())) - 5this is
	 * the offset from AABB hitbox to texture ; player.setX(newX);
	 * AABB.setBounds((int)player.adjustXforCollision(newX),
	 * (int)player.adjustYforCollision(posY), AABB.width, AABB.height);
	 * player.setMotionX(0); player.setMoving(false);
	 * 
	 * if(Game.debug) { System.out.println("Collided top left horizontally"); }
	 * 
	 * }
	 * 
	 * if(getTile(convertToTiles((int)AABB.getMinX()),
	 * convertToTiles((int)AABB.getMaxY() - 1)) != null && !isOnMovingTile) { //this
	 * is the bottom left corner newX =
	 * convertToPixels(convertToTiles((int)AABB.getMaxX())) - 5this is the offset
	 * from AABB hitbox to texture ; player.setX(newX);
	 * AABB.setBounds((int)player.adjustXforCollision(newX),
	 * (int)player.adjustYforCollision(posY), AABB.width, AABB.height);
	 * player.setMotionX(0); player.setMoving(false);
	 * 
	 * if(Game.debug) { System.out.println("Collided bottom left horizontally"); } }
	 * 
	 * if (newX == -1.0) { newX = toX; }
	 * 
	 * if((int)newX < 0) { //colliding with the map boundry player.setX(1);
	 * player.setMotionX(0); player.setMoving(false); }
	 * 
	 * if((int)newX + 64 > convertToPixels(this.width)) {
	 * player.setX(convertToPixels(this.width) - 64); // must change this
	 * player.setMotionX(0); player.setMoving(false); }
	 * 
	 * //horz is first, now vert;
	 * 
	 * AABB.setBounds((int)player.adjustXforCollision(newX),
	 * (int)player.adjustYforCollision(toY), AABB.width, AABB.height);
	 * 
	 * if(getTile(convertToTiles((int)AABB.getMaxX() - 1),
	 * convertToTiles((int)AABB.getMinY())) != null) { // this is the top right
	 * corner player.setMotionY(motionY / 4);
	 * 
	 * if(Game.debug) { System.out.println("Collided top left vertically"); }
	 * 
	 * }
	 * 
	 * if(getTile(convertToTiles((int)AABB.getMinX() + 1),
	 * convertToTiles((int)AABB.getMinY())) != null) { // this is the top left
	 * corner player.setMotionY(motionY / 4);
	 * 
	 * if(Game.debug) { System.out.println("Collided top right vertically"); }
	 * 
	 * }
	 * 
	 * 
	 * if(getTile(convertToTiles((int)AABB.getMaxX() - 1),
	 * convertToTiles((int)AABB.getMaxY())) != null && !isOnMovingTile) { // this is
	 * the bottom right corner Tile tile =
	 * getTile(convertToTiles((int)AABB.getMaxX() - 1),
	 * convertToTiles((int)AABB.getMaxY())); if(tile.type == TileType.SOLID) {
	 * player.setY(convertToPixels(convertToTiles((int)player.adjustYforCollision(
	 * posY)))); player.setMotionY(0); player.setAirBorne(false);
	 * 
	 * if(Game.debug) { System.out.println("Collided bottom right vertically"); } }
	 * else { if(tile.type == TileType.SLOPE_RIGHT_64_00) {
	 * //player.setY(tilesToPixels(pixelsToTiles((int)(int)player.ajustYforCollision
	 * (posY))) - 64 + toX % 64);
	 * player.setY(convertToPixels(convertToTiles((int)(int)player.
	 * adjustYforCollision(posY))) + (64 - toX % 64)); player.setMotionY(0);
	 * player.setAirBorne(false); if(Game.debug) {
	 * System.out.println("Still walking up a slope"); } } } }
	 * 
	 * if(getTile(convertToTiles((int)AABB.getMinX() + 1),
	 * convertToTiles((int)AABB.getMaxY())) != null) { // this is the bottom left
	 * corner Tile tile = getTile(convertToTiles((int)AABB.getMinX() + 1),
	 * convertToTiles((int)AABB.getMaxY())); if(tile.type == TileType.SOLID) {
	 * player.setY(convertToPixels(convertToTiles((int)(int)player.
	 * adjustYforCollision(posY)))); player.setMotionY(0);
	 * player.setAirBorne(false); if(Game.debug) {
	 * System.out.println("Collided bottom left vertically"); } } else {
	 * if(tile.type == TileType.SLOPE_RIGHT_64_00) {
	 * //player.setY(tilesToPixels(pixelsToTiles((int)(int)player.ajustYforCollision
	 * (posY))) - 64 + toX % 64);
	 * player.setY(convertToPixels(convertToTiles((int)(int)player.
	 * adjustYforCollision(posY))) + (64 - toX % 64)); player.setMotionY(0);
	 * player.setAirBorne(false); if(Game.debug) {
	 * System.out.println("Still walking up a slope"); } } } }
	 * 
	 * isOnMovingTile = false;
	 * 
	 * //Entity Collision for (Entity e : entities) { if (e instanceof
	 * EntityMovingTile) { EntityMovingTile movingTile = (EntityMovingTile)e;
	 * 
	 * if (player.getAABB().getMaxY() > movingTile.getAABB().getMinY() &&
	 * player.getAABB().getMaxY() < movingTile.getAABB().getMaxY() &&
	 * player.getAABB().getMaxX() > movingTile.getAABB().getMinX() &&
	 * player.getAABB().getMaxX() < movingTile.getAABB().getMaxX() && player.getY()
	 * + 60 <= movingTile.getAABB().getMinY()) { // this is the bottom right corner
	 * 
	 * player.setY(movingTile.getAABB().getMinY() - 62); player.setMotionY(0);
	 * player.setAirBorne(false); movingTile.setCollided(true); isOnMovingTile =
	 * true;
	 * 
	 * if(movingTile.getMotionY() > 0) { player.setY(movingTile.getAABB().getMinY()
	 * - 62); }
	 * 
	 * if(!player.isMoving() && movingTile.getPlatformType() ==
	 * PlatformType.HORIZONTAL_MOVING) {
	 * //player.setMotionX(movingTile.getMotionX()*2.4); //2.4 is a constant that
	 * prevents traction from slowing down the player player.setX(player.getX() +
	 * movingTile.getMotionX()); //player.setMotionY(movingTile.getMotionY()); }
	 * else { player.setMotionX(player.getMotionX() + movingTile.getMotionX()); }
	 * 
	 * if (Game.debug) {
	 * System.out.println("Collided bottom left with an entity vertically"); }
	 * 
	 * } else { if (player.getAABB().getMaxY() > movingTile.getAABB().getMinY() &&
	 * player.getAABB().getMaxY() < movingTile.getAABB().getMaxY() &&
	 * player.getAABB().getMinX() < movingTile.getAABB().getMaxX() &&
	 * player.getAABB().getMinX() > movingTile.getAABB().getMinX() && player.getY()
	 * + 60 <= movingTile.getAABB().getMinY()) { // this is the bottom left corner
	 * 
	 * player.setY(movingTile.getAABB().getMinY() - 62); player.setMotionY(0);
	 * player.state.toPlatform(); movingTile.setCollided(true); isOnMovingTile =
	 * true;
	 * 
	 * if(movingTile.getMotionY() > 0) { player.setY(movingTile.getAABB().getMinY()
	 * - 62); }
	 * 
	 * if(!player.state.isMoving() && movingTile.getPlatformType() ==
	 * PlatformType.HORIZONTAL_MOVING) {
	 * player.setMotionX(movingTile.getMotionX()*2.4); //2.4 is a constant that
	 * prevents traction from slowing down the player
	 * player.setMotionY(movingTile.getMotionY()); }
	 * 
	 * if(movingTile.getPlatformType() == PlatformType.FALLING) {
	 * //player.setY(movingTile.getY() + movingTile.getMotionY());
	 * player.setMotionY(movingTile.getMotionY()); }
	 * 
	 * if (Game.debug) {
	 * System.out.println("Collided bottom right with an entity vertically"); } } }
	 * } } }
	 */

	public void wallCollisionLeft(Rectangle AABB, double posX, double posY, double motionX, double motionY,
			double cornerX, double cornerY, double offset) {
		if (getTile(convertToTiles((int) cornerX), convertToTiles((int) cornerY)) != null) {
			Tile t = getTile(convertToTiles((int) cornerX), convertToTiles((int) cornerY));
			if (TileType.isCubeType(t.type) || TileType.isSlopeRightType(t.type)) {
				newX = convertToPixels(convertToTiles((int) cornerX)) + offset;
				player.setX(newX);
				AABB.setBounds((int) player.adjustXforCollision(newX), (int) player.adjustYforCollision(posY),
						AABB.width, AABB.height);
				player.setMotionX(0);
				player.setMoving(false);
			}

		}
	}

	public void wallCollisionRight(Rectangle AABB, double posX, double posY, double motionX, double motionY,
			double cornerX, double cornerY, double offset) {
		if (getTile(convertToTiles((int) cornerX), convertToTiles((int) cornerY)) != null) {
			Tile t = getTile(convertToTiles((int) cornerX), convertToTiles((int) cornerY));
			if (TileType.isCubeType(t.type) || TileType.isSlopeLeftType(t.type)) {
				newX = convertToPixels(convertToTiles((int) cornerX)) + offset;
				player.setX(newX);
				AABB.setBounds((int) player.adjustXforCollision(newX), (int) player.adjustYforCollision(posY),
						AABB.width, AABB.height);
				player.setMotionX(0);
				player.setMoving(false);
			}
		}

	}

	public void ceilingCollision(Rectangle AABB, double motionY, double cornerX, double cornerY) {
		if (getTile(convertToTiles((int) cornerX), convertToTiles((int) cornerY)) != null) {
			player.setMotionY(motionY / 4);

		}

	}

	public boolean ceilingCollision(double cornerX, double cornerY) {
		if (getTile(convertToTiles((int) cornerX), convertToTiles((int) cornerY)).type.isNotAir()) {
			player.setMotionY(player.getMotionY() / 4);
			return true;
		}
		return false;
	}

	public void floorCollision(Rectangle AABB, double posY, double cornerX, double cornerY) {
		if (getTile(convertToTiles((int) cornerX), convertToTiles((int) cornerY)) != null) {
			Tile t = getTile(convertToTiles((int) cornerX), convertToTiles((int) cornerY));
			if (TileType.isSlope(t.type)) {
				return;
			}
			player.setY(convertToPixels(convertToTiles((int) player.adjustYforCollision(posY))));
			player.setMotionY(0);
			player.setAirBorne(false);
			AABB.setBounds((int) player.adjustXforCollision(player.getX()),
					(int) player.adjustYforCollision(player.getY()), AABB.width, AABB.height);
		}
	}

	public boolean movingTileCollision(EntityMovingTile movingTile, double cornerX, double cornerY) {
		double tileLeftX = movingTile.getAABB().getMinX();
		double tileRightX = movingTile.getAABB().getMaxX();
		double tileTop = movingTile.getAABB().getMinY();
		double tileBottom = movingTile.getAABB().getMaxY();
		// These 4 variables are purely to make the code more understandable, as calling
		// these functions each time is very messy

		if (cornerY > tileTop // the corner y position checked is within the bounds of the hitbox (remember
								// that higher y value is reletively lower in the map)
				&& cornerY < tileBottom && cornerX > tileLeftX // the corner x position checked is within the left and
																// right bounds of the hitbox
				&& cornerX < tileRightX && player.getY() + 60 <= tileTop) {

			player.setY(movingTile.getAABB().getMinY() - 62); // sets the y value to 2 pixels inside the platform, this
																// is to prevent the player from "falling" while they
																// are moving on a vertical platform
			player.setMotionY(0); // while on a platform the Y motion is controlled by the platform itself, so
									// player motion y must be 0
			player.setAirBorne(false); // player isn't in the air if it is on a platform
			movingTile.setCollided(true); // causes the platform to fall if it is a falling platform
			player.getAABB().setBounds((int) player.adjustXforCollision(player.getX()),
					(int) player.adjustYforCollision(player.getY()), player.getAABB().width, player.getAABB().height); // updates
																														// the
																														// hitbox
																														// position
			return true; // method returns true if collision occured
		}
		return false; // and false if it didn't
	}

	public boolean slopeCollisionRight(Rectangle AABB, double posX, double posY, double motionX, double motionY,
			double cornerX, double cornerY, Triangle t) {
		if (t.intersects(cornerX, cornerY, player) && motionY >= 0) {
			double newY = t.getHPoints()[(int) (cornerX - (t.getA().getX()))].getY() - 62;
			// System.out.println("Hitting a Slope");
			player.setY(newY);
			player.setX(posX + motionX);
			// player.setMotionX(motionX / 1.2);
			player.getAABB().setBounds((int) player.adjustXforCollision(player.getX()),
					(int) player.adjustYforCollision(player.getY()), player.getAABB().width, player.getAABB().height);
			player.setMotionY(0);
			player.setAirBorne(false);
			// System.out.println();
			return true;
		} else {
			if ((t.intersects(cornerX, cornerY + 10, player) && !player.isAirBorne()) && motionY >= 0) {
				double newY = t.getHPoints()[(int) (cornerX - (t.getA().getX()))].getY() - 60;
				// System.out.println("Hitting a Slope");
				player.setY(newY);
				player.setX(posX + motionX);
				// player.setMotionX(player.getMotionX() /1.1);
				player.getAABB().setBounds((int) player.adjustXforCollision(player.getX()),
						(int) player.adjustYforCollision(player.getY()), player.getAABB().width,
						player.getAABB().height);
				player.setMotionY(0);
				player.setAirBorne(false);
				// System.out.println();
				return true;
			}
		}

		return false;
	}

	public boolean slopeCalculation(double cornerX, double cornerY) {
		if (getTile(convertToTiles((int) cornerX), convertToTiles((int) cornerY)) != null) {
			return !TileType.isCubeType(getTile(convertToTiles((int) cornerX), convertToTiles((int) cornerY)).type);
		}
		return false;
	}

	public void calculateCollision(Rectangle AABB, double posX, double posY, double motionX, double motionY,
			boolean b) {
		double toX = posX + motionX;
		double toY = posY + motionY;
		newX = -1.0;

		/*
		 * if(slopeCalculation(AABB.getMaxX(), AABB.getMinY() +
		 * 1)||slopeCalculation(AABB.getMaxX(), AABB.getMaxY() -
		 * 1)||slopeCalculation(AABB.getMinX(), AABB.getMinY() +
		 * 1)||slopeCalculation(AABB.getMinX(), AABB.getMaxY() - 1)) { player.state =
		 * player.state.toSlope(); }
		 */

		double slopeCornerX = AABB.getMaxX();
		for (int i = (int) AABB.getMinX(); i <= (int) AABB.getMaxX(); i++) {
			if (slopeCalculation(i, AABB.getMaxY() - 1)
			/* || slopeCalculation(AABB.getMinX(), AABB.getMaxY() - 1) */) {
				player.setAirBorne(false);
				slopeCornerX = i;
			}
		}
		AABB.setBounds((int) player.adjustXforCollision(toX), (int) player.adjustYforCollision(posY), AABB.width,
				AABB.height);
		// double[] arr = {newX , toX};

		for (Triangle t : slopeTriangles) {
			if (slopeCollisionRight(AABB, posX, posY, motionX, motionY, slopeCornerX - 1, AABB.getMaxY(),
					t)/*
						 * || slopeCollisionRight(AABB, posX, posY, motionX, motionY, AABB.getMinX()+1,
						 * AABB.getMaxY(),t)
						 */) {
				return;
			}
		}
		if (player.hasCollision) {
			wallCollisionRight(AABB, posX, posY, motionX, motionY, AABB.getMaxX(), AABB.getMinY() + 1,
					-AABB.getWidth() - 1 - 5); // this is the top right corner
			wallCollisionRight(AABB, posX, posY, motionX, motionY, AABB.getMaxX(), AABB.getMaxY() - 1,
					-AABB.getWidth() - 1 - 5); // this is the bottom right corner
			wallCollisionLeft(AABB, posX, posY, motionX, motionY, AABB.getMinX(), AABB.getMinY() + 1, +64 - 5); // this
																												// is
																												// the
																												// top
																												// left
																												// corner
			wallCollisionLeft(AABB, posX, posY, motionX, motionY, AABB.getMinX(), AABB.getMaxY() - 1, 64 - 5); // this
																												// is
																												// the
																												// bottom
																												// left
																												// corner
		}

		if (newX == -1.0) {
			newX = toX;
		}

		if ((int) newX < 0) { // colliding with the map boundry
			player.setX(1);
			player.setMotionX(0);
			player.setMoving(false);
		}

		if ((int) newX + 64 > convertToPixels(this.width)) {
			player.setX(convertToPixels(this.width) - 64); // must change this
			player.setMotionX(0);
			player.setMoving(false);
		}

		// horz is first, now vert;

		AABB.setBounds((int) player.adjustXforCollision(newX), (int) player.adjustYforCollision(toY), AABB.width,
				AABB.height);

		ceilingCollision(AABB, motionY, AABB.getMaxX() - 1, AABB.getMinY()); // this is the top right corner
		ceilingCollision(AABB, motionY, AABB.getMinX() + 1, AABB.getMinY()); // this is the top left corner

		if (player.hasCollision) {
			floorCollision(AABB, posY, AABB.getMaxX() - 1, AABB.getMaxY()); // this is the bottom right corner
			floorCollision(AABB, posY, AABB.getMinX() + 1, AABB.getMaxY()); // this is the bottom left corner
		}

		// slopeCollisionRight(AABB, posX, posY, AABB.getMaxY() - 1); //this checks
		// slopes

		player.onMovingTile = false;

		// Entity Collision
		for (Entity e : entities) {
			if (e instanceof EntityMovingTile) {

				EntityMovingTile movingTile = (EntityMovingTile) e;
				if (movingTileCollision(movingTile, player.getAABB().getMaxX(), player.getAABB().getMaxY()) || // this
																												// is
																												// the
																												// bottom
																												// right
																												// corner
						movingTileCollision(movingTile, player.getAABB().getMinX(), player.getAABB().getMaxY())) { // this
																													// is
																													// the
																													// bottom
																													// left
																													// corner

					/*
					 * if (!player.isMoving()) { //if player is not moving horizontally, this
					 * updates the players X position to follow the moving tile
					 * player.setX(player.getX() + movingTile.getMotionX()); } else {
					 * if((player.getMotionX() > 0 && movingTile.getMotionX() >
					 * 0)||(player.getMotionX() < 0 && movingTile.getMotionX() < 0)) {
					 * player.setMotionX(player.getMotionX() + movingTile.getMotionX()/2); } else {
					 * player.setMotionX(player.getMotionX() - movingTile.getMotionX()/2); } }
					 */
					player.onMovingTile = true;
					player.setX(player.getX() + movingTile.getMotionX());

					ceilingCollision(AABB, motionY, AABB.getMaxX() - 1, AABB.getMinY());
					ceilingCollision(AABB, motionY, AABB.getMinX() + 1, AABB.getMinY());

					floorCollision(AABB, player.getY(), AABB.getMaxX() - 1, AABB.getMaxY());
					floorCollision(AABB, player.getY(), AABB.getMinX() + 1, AABB.getMaxY());
				}
			}
		}
	}

	public boolean calculateNPCCollision(Mob mob, double posX, double posY, double motionX, double motionY) {
		boolean returnType = false;
		double toX = posX + motionX;
		double toY = posY + motionY;
		double newX = -1.0;
		mob.getAABB().setBounds((int) toX, (int) posY, mob.getAABB().width, mob.getAABB().height);

		if (getTile(convertToTiles((int) mob.getAABB().getMaxX()),
				convertToTiles((int) mob.getAABB().getMinY() + 1)) != null) { // this is the top right corner
			Tile tile = getTile(convertToTiles((int) mob.getAABB().getMaxX()),
					convertToTiles((int) mob.getAABB().getMinY() + 1));
			if (tile.type == TileType.SOLID) {
				newX = convertToPixels(convertToTiles((int) mob.getAABB().getMaxX())) - mob.getAABB().getWidth() - 1
						- 5;
				mob.setX(newX);
				mob.getAABB().setBounds((int) newX, (int) posY, mob.getAABB().width, mob.getAABB().height);
				mob.setMotionX(0);
			    mob.setMoving(false);

				returnType = true;

			} else {
				if (tile.type == TileType.SLOPE_RIGHT_64_00) {
					newX = toX;
					if (Game.debug) {
						System.out.println("Walking up a slope");
					}
				}
			}
		}

		if (getTile(convertToTiles((int) mob.getAABB().getMaxX()),
				convertToTiles((int) mob.getAABB().getMaxY() - 1)).type.isNotAir()) { // this is the bottom right corner
			Tile tile = getTile(convertToTiles((int) mob.getAABB().getMaxX()),
					convertToTiles((int) mob.getAABB().getMaxY() - 1));
			if (tile.type == TileType.SOLID) {
				newX = convertToPixels(convertToTiles((int) mob.getAABB().getMaxX())) - mob.getAABB().getWidth() - 1
						- 5;
				mob.setX(newX);
				mob.getAABB().setBounds((int) newX, (int) posY, mob.getAABB().width, mob.getAABB().height);
				mob.setMotionX(0);
				mob.setMoving(false);
				returnType = true;

			} else {
				if (tile.type == TileType.SLOPE_RIGHT_64_00) {

				}
			}
		}

		if (getTile(convertToTiles((int) mob.getAABB().getMinX()),
				convertToTiles((int) mob.getAABB().getMinY() + 1)).type.isNotAir()) { // this is the top left corner
			newX = convertToPixels(convertToTiles((int) mob.getAABB().getMaxX()))
					- 5/* this is the offset from mob.getAABB() hitbox to texture */ + 1;
			mob.setX(newX);
			mob.getAABB().setBounds((int) newX, (int) posY, mob.getAABB().width, mob.getAABB().height);
			mob.setMotionX(0);
			mob.setMoving(false);

			returnType = true;

		}

		if (getTile(convertToTiles((int) mob.getAABB().getMinX()),
				convertToTiles((int) mob.getAABB().getMaxY() - 1)).type.isNotAir() && !isOnMovingTile) { // this is the bottom
																									// left corner
			newX = convertToPixels(convertToTiles((int) mob.getAABB().getMaxX()))
					- 5/* this is the offset from mob.getAABB() hitbox to texture */ + 1;
			mob.setX(newX);
			mob.getAABB().setBounds((int) newX, (int) posY, mob.getAABB().width, mob.getAABB().height);
			mob.setMotionX(0);
			mob.setMoving(false);

			returnType = true;

		}

		if (newX == -1.0) {
			newX = toX;
		}

		if ((int) newX < 0) { // colliding with the map boundry
			mob.setX(1);
			mob.setMotionX(0);
			mob.setMoving(false);
			returnType = true;
		}

		if ((int) newX + 64 > convertToPixels(this.width)) {
			mob.setX(convertToPixels(this.width) - 64); // must change this
			mob.setMotionX(0);
			mob.setMoving(false);
			returnType = true;
		}

		// horz is first, now vert;

		mob.getAABB().setBounds((int) newX, (int) toY, mob.getAABB().width, mob.getAABB().height);

		if (getTile(convertToTiles((int) mob.getAABB().getMaxX() - 1),
				convertToTiles((int) mob.getAABB().getMinY())).type.isNotAir()) { // this is the top right corner
			mob.setMotionY(motionY / 4);

		}

		if (getTile(convertToTiles((int) mob.getAABB().getMinX() + 1),
				convertToTiles((int) mob.getAABB().getMinY())).type.isNotAir()) { // this is the top left corner
			mob.setMotionY(motionY / 4);

		}

		if (getTile(convertToTiles((int) mob.getAABB().getMaxX() - 1),
				convertToTiles((int) mob.getAABB().getMaxY())).type.isNotAir() && !isOnMovingTile) { // this is the bottom right
																								// corner
			Tile tile = getTile(convertToTiles((int) mob.getAABB().getMaxX() - 1),
					convertToTiles((int) mob.getAABB().getMaxY()));
			if (tile.type == TileType.SOLID) {
				mob.setY(convertToPixels(convertToTiles((int) posY + 10)));
				mob.setMotionY(0);
				mob.setMoving(false);
			} else {
				if (tile.type == TileType.SLOPE_RIGHT_64_00) {

				}
			}
		}

		if (getTile(convertToTiles((int) mob.getAABB().getMinX() + 1),
				convertToTiles((int) mob.getAABB().getMaxY())).type.isNotAir()) { // this is the bottom left corner
			Tile tile = getTile(convertToTiles((int) mob.getAABB().getMinX() + 1),
					convertToTiles((int) mob.getAABB().getMaxY()));
			if (tile.type == TileType.SOLID) {
				mob.setY(convertToPixels(convertToTiles((int) posY + 10)));
				mob.setMotionY(0);
				mob.setMoving(false);
			} else {
				if (tile.type == TileType.SLOPE_RIGHT_64_00) {

				}
			}
		}

		isOnMovingTile = false;

		// Entity Collision
		for (Entity e : entities) {
			if (e instanceof EntityMovingTile && mob.hasCollision) {
				EntityMovingTile movingTile = (EntityMovingTile) e;

				if (mob.getAABB().getMaxY() > movingTile.getAABB().getMinY()
						&& mob.getAABB().getMaxY() < movingTile.getAABB().getMaxY()
						&& mob.getAABB().getMaxX() > movingTile.getAABB().getMinX()
						&& mob.getAABB().getMaxX() < movingTile.getAABB().getMaxX()
						&& mob.getY() + 60 <= movingTile.getAABB().getMinY()) { // this is the bottom right corner

					mob.setY(movingTile.getAABB().getMinY() - 62);
					mob.setMotionY(0);
					mob.setAirBorne(false);
					movingTile.setCollided(true);
					isOnMovingTile = true;

					if (movingTile.getMotionY() > 0) {
						mob.setY(movingTile.getAABB().getMinY() - 62);
					} else {
						mob.setMotionX(mob.getMotionX() + movingTile.getMotionX());
					}

					/*
					 * if(!mob.isMoving() && movingTile.getPlatformType() ==
					 * PlatformType.HORIZONTAL_MOVING) {
					 * //player.setMotionX(movingTile.getMotionX()*2.4); //2.4 is a constant that
					 * prevents traction from slowing down the player mob.setX(mob.getX() +
					 * movingTile.getMotionX()); //player.setMotionY(movingTile.getMotionY()); }
					 */

					mob.setX(mob.getX() + movingTile.getMotionX());

				} else {
					if (mob.getAABB().getMaxY() > movingTile.getAABB().getMinY()
							&& mob.getAABB().getMaxY() < movingTile.getAABB().getMaxY()
							&& mob.getAABB().getMinX() < movingTile.getAABB().getMaxX()
							&& mob.getAABB().getMinX() > movingTile.getAABB().getMinX()
							&& mob.getY() + 60 <= movingTile.getAABB().getMinY()) { // this is the bottom left corner

						mob.setY(movingTile.getAABB().getMinY() - 62);
						mob.setMotionY(0);
						mob.setAirBorne(false);
						movingTile.setCollided(true);
						isOnMovingTile = true;

						if (movingTile.getMotionY() > 0) {
							mob.setY(movingTile.getAABB().getMinY() - 62);
						}

						if (!mob.isMoving()/* && movingTile.getPlatformType() == PlatformType.HORIZONTAL_MOVING */) {
							mob.setMotionX(movingTile.getMotionX() * 2.4); // 2.4 is a constant that prevents traction
																			// from slowing down the player
							mob.setMotionY(movingTile.getMotionY());
						}

					}
				}
			} else {
				if (e instanceof EntityBoop) {
					EntityBoop boop = (EntityBoop) e;
					if (player.getAABB().intersects(boop.getAABB())) {
						if (boop.getY() - player.getY() < 48) {
							//boop.onHit(player);
						} else {
							//boop.onKillHit(player);
						}
					}
				}
			}
		}
		return returnType;
	}

	public void load(String name) {
		usedTiles.clear();
		this.name = name;
		BufferedImage image = null;
		try {
			image = ImageIO.read(new File("src/assets/levels/" + name + ".png"));
			System.out.println("read: " + name);
		} catch (IOException e) {
			e.printStackTrace();
		}

		this.name = name;
		this.width = image.getWidth();
		this.height = image.getHeight();
		tiles = new Tile[width * height];
		int[] pixels = image.getRGB(0, 0, width, height, null, 0, width);

		for (int y = 0; y < height; y++) {
			for (int x = 0; x < width; x++) {
				int id = pixels[x + y * width];
				setTile(x, y, Tile.getFromID(-2));
				if (id == 0xFF0000FF) {
					player = new Player(convertToPixels(x), convertToPixels(y), this);
					player.setPlayerSpawnX(convertToPixels(x));
					player.setPlayerSpawnY(convertToPixels(y));
				} else {
					if (Tile.getFromID(id) != null) {
						setTile(x, y, Tile.getFromID(id));
						if (Tile.getFromID(id).type == TileType.SLOPE_RIGHT_64_00) {
							slopeTriangles.add(new Triangle(new Point(convertToPixels(x), convertToPixels(y) + 64), 64,
									Math.PI / 4));
						}
					} else {
						if (id == 0xFF010101) {
							System.out.println("Goal is " + convertToPixels(x) + " ," + convertToPixels(y));
						} else {
							if (id == 0xFF000001) {
								System.out.println(convertToPixels(x) + " ," + convertToPixels(y));
							}
						}
					}
				}
			}

			setTile(6, 13, Tile.slope1);
			setTile(7, 13, Tile.slope2);
			setTile(8, 13, Tile.slope3);
			setTile(9, 13, Tile.slope4);
			setTile(10, 13, Tile.tile1);
			/*
			 * setTile(11, 13, Tile.slope5); setTile(12, 13, Tile.slope6); setTile(13, 13,
			 * Tile.slope7); setTile(14, 13, Tile.slope8);
			 */

			/*
			 * EntityMovingTile movingTile = new EntityMovingTile(new Texture("movingTile"),
			 * 1000, 300, this, new Rectangle(100, 100, 128, 20), 200,
			 * PlatformType.VERTICAL_MOVING); EntityMovingTile movingTile1 = new
			 * EntityMovingTile(new Texture("movingTile"), 100, 500, this, new
			 * Rectangle(100, 100, 128, 20), 100, PlatformType.HORIZONTAL_MOVING);
			 * EntityMovingTile movingTile2 = new EntityMovingTile(new
			 * Texture("movingTile"), 1500, 300, this, new Rectangle(100, 100, 128, 20),
			 * 100, PlatformType.FALLING); EntityGoal goal = new EntityGoal(new Texture(new
			 * Texture("SpriteMap1"), 4, 1 , 64, 64), 1000.0, 400.0, this, new
			 * Rectangle(1000, 400, 64, 64)); addEntity(movingTile); addEntity(movingTile1);
			 * addEntity(movingTile2); addEntity(goal);
			 */

		}

	}

	public void unload() {
		for (Entity e : entities) {
			e.setDead();
			e = null;
		}
		entities.clear();

	}

	public String getLevelName() {
		return name;
	}

	public void setEntityList(Entity[] arr) {
		entities.clear();
		for (Entity e : arr) {
			entities.add(e);
		}
	}

	public void addEntity(Entity e) {
		if (!(e instanceof Player)) {
			entities.add(e);
		}
	}

	public void removeEntity(Entity e) {
		if (!(e instanceof Player)) {
			entities.remove(e);
		}
	}

	public ArrayList<Entity> getEntities() {
		return entities;
	}

	public Player getPlayer() {
		return player;
	}

	public int getHeight() {
		return height;
	}

	public int getWidth() {
		return width;
	}

	public void killEntity(Entity e) {
		removeEntity(e);
		// e = null;
	}

}
